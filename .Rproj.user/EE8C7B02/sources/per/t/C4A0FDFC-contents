# In this file all invisible helper functions are placed




# First define the internal functions:

# the function 'Calculate_laspeyres' calls the folowing internal functions a) calculate_hedonic_imputation b) calculate_index
# c) show_progress_loop






# define the 1st internal function 'calculate_hedonic_imputation'


#' Title Calculation of a hedonic imputation
#' @author Farley Ishaak
#' @param dataset_temp = table with data (hoeft no selectie te zijn van benodigde variables)
#' @param Period_temp = 'Period'
#' @param dependent_variable_temp = usually the sale price
#' @param independent_variables_temp = vector with quality determining variables
#' @param log_dependent_temp = should the dependent variable be transformed to its logarithm? default = TRUE
#' @param period_list_temp = list with all available periods
#' @return
#'         table with imputation averages per period
#' @keywords internal


calculate_hedonic_imputation <- function(dataset_temp
                                         , Period_temp
                                         , dependent_variable_temp
                                         , independent_variables_temp
                                         , log_dependent_temp
                                         , number_of_observations_temp
                                         , period_list_temp){

  ## Data operations

  # Count number of periods
  number_of_periods <- length(period_list_temp)

  # Select required variables
  dataset_temp <- dataset_temp[, (names(dataset_temp) %in% c(Period_temp, dependent_variable_temp, independent_variables_temp))]

  # Remove lines without values
  dataset_temp[dataset_temp == ''] <- NA
  dataset_temp <- stats::na.omit(dataset_temp)

  # Remove unused levels. R remembers the original state of the levels, but if a level is not present in a certain period, this may result in an error in the bootstrap.
  dataset_temp <- droplevels(dataset_temp)

  # If parameter log_dependent = TRUE, transform to log
  if(log_dependent_temp == TRUE){
    dependent_variable_temp <- paste0("log(", dependent_variable_temp, ")")
  }

  ## Model

  # Compile model
  for (v in 1: length(independent_variables_temp)){
    if (v==1) {
      model <- paste0(dependent_variable_temp,"~",independent_variables_temp[v])
    } else {
      model <- paste0(model,"+",independent_variables_temp[v])
    }
  }

  ## Calculate imputations per period

  # Empty vector for the values and numbers
  average_Imputations <- c()
  number_observations_total <- c()

  Period_var_temp <- NULL # To prevent that the following note occurs: 'no visible binding for global variable 'Period_var_temp' '
  for (p in 1:number_of_periods){

    # Estimate coefficients of the 1th period
    if (p==1) {
      Rekenbestand <- subset(dataset_temp, Period_var_temp == period_list_temp[1])
      fitmdl <- stats::lm(model,Rekenbestand)
      predictmdl_0 <- mean(stats::predict(fitmdl, Rekenbestand))

      # If parameter log_dependent = TRUE, then reverse with exp()
      if(log_dependent_temp == TRUE){predictmdl_0 <- exp(predictmdl_0)}

      # If parameter number_of_observations = TRUE, then calculate numbers
      if(number_of_observations_temp == TRUE){number <- nrow(Rekenbestand)}

    } else {
      # Estimate coefficients of all periods after
      Rekenbestand_t <- subset(dataset_temp,Period_var_temp==period_list_temp[p])
      fitmdl <- stats::lm(model,Rekenbestand_t)

      # If parameter number_of_observations = TRUE, then calculate numbers
      if(number_of_observations_temp == TRUE){number <- nrow(Rekenbestand_t)}

    }

    # Recoding of values, where the categorical variable has a level that is not estimated in the reference period
    Rekenbestand_0 <- Rekenbestand
    for (var in names(fitmdl$xlevels)) {
      missend_in_model <- levels(Rekenbestand_0[[var]])[!(levels(Rekenbestand_0[[var]]) %in% fitmdl$xlevels[[var]])]

      # Replace level of the variable by the first level (default). The variable is in fact not taken into account by this step in the calculation.
      sel <- Rekenbestand_0[[var]] %in% missend_in_model
      Rekenbestand_0[[var]][sel] <- fitmdl$xlevels[[var]][1]
    }
    predictmdl_t <- mean(predict(fitmdl, Rekenbestand_0))

    # If parameter log_dependent = TRUE, then reverse with exp()
    if(log_dependent_temp == TRUE){predictmdl_t <- exp(predictmdl_t)}

    average_Imputations[p] <- predictmdl_t

    # If parameter number_of_observations = TRUE, then add numbers to table
    if(number_of_observations_temp == TRUE){number_observations_total[p] <- number}

  }

  # Create table
  Tbl_average_imputation <- data.frame(Period=period_list_temp)

  # If parameter number_of_observations = TRUE, then add numbers to table
  if(number_of_observations_temp == TRUE){Tbl_average_imputation$number_of_observations <- number_observations_total}

  # Add imputations to table
  Tbl_average_imputation$average_imputation <- average_Imputations

  # Result
  return(Tbl_average_imputation)

}

# define the 2nd internal function 'calculate_index'

#' Transform series into index
#'
#' The index can be calculated in two ways:
#' - from a series of values
#' - from a series of mutations (from_growth_rate = TRUE)
#'
#' N.B. with from_growth_rate:
#' The series of mutations must be equally long to the series of values.
#' Thee vector should, therefore, also contain a mutation for the first period (this is likely 1).
#' In the calculation, this first mutation is not used.
#'
#' N.B. for the reference period:
#' The first value is on default set to 100.
#' An adjusted reference period can be provided in the paramater.
#' The reference period can also be a part of a period.
#' E.g. if the series contains months (2019jan, 2019feb), the reference period can be a year (2019).
#'
#' @author Farley Ishaak
#' @param periods = vector/variable with periods (numeric/string)
#' @param values = vector/variable with to be transformed values (numeric)
#' @param reference_period = period or group of periods that will be set to 100 (numeric/string)
#' @param from_growth_rate = is the index calculated from a growth rate (deviation from 1)? If not, then the index is calculated from a series of values (default = FALSE)
#' @return Index series
#' @keywords internal
calculate_index <- function(periods
                            , values
                            , reference_period = NULL
                            , from_growth_rate = FALSE){

  # Check length periods and values
  if(length(periods) != length(values)){
    stop('De reeks with periods is niet even lang als the reeks with values')
  }

  # Check numeric values
  if(is.numeric(values) == FALSE){
    stop('De reeks with values is niet (volledig) numeric')
  }

  # Transforms periods to characters
  periods <- as.character(periods)

  # If reference_period is not provided, then reference_period = 1th period from list
  if(is.null(reference_period) == TRUE){
    reference_period <- periods[1]
    periods_short <- periods
  } else {
    # Determine lengte reference_period
    Length_reference_period <- nchar(reference_period)
    periods_short <- substr(periods, 1, Length_reference_period)
  }

  # Check reference_period
  if(!reference_period %in% periods_short){
    stop('The provided reference period is not part of the series with periods')
  }

  # Transform growth_rate to index
  if(from_growth_rate == TRUE){
    values[1] <- 1
    values <- cumprod(values) * 100
  }

  # Create table
  Value <- NULL # To prevent that the following note occurs: 'no visible binding for global variable 'Value' '
  period <- NULL # To prevent that the following note occurs: 'no visible binding for global variable 'period' '
  Tbl_index <- data.frame(period = periods_short, Value = values)

  # Determine value reference_period
  Average <- dplyr::filter(Tbl_index, period == reference_period)
  Average <- dplyr::summarise(Average, Value = mean(Value))
  Average <- as.vector(Average$Value)

  # Calculate index
  Tbl_index$Index <- Tbl_index$Value/Average*100

  # Result = index series
  return(index = Tbl_index$Index)

}


# define the 3rd internal function 'show_progress_loop'

#' Title
#'
#' @param single_iteration = a single iteration (usually 1 letter: i or p)
#' @param total_iterations = the total number of iterations in the loop
#'
#' @return this returns a progress text
#' @keywords internal
show_progress_loop <- function(single_iteration
                               , total_iterations){

  cat(sprintf("\rProgress: %3d%%", round(single_iteration / total_iterations * 100)))
  if (single_iteration == total_iterations) message("\n Done!")

}
